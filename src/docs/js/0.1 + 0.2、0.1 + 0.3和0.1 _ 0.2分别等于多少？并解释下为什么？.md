# 0.1 + 0.2、0.1 + 0.3和0.1 _ 0.2分别等于多少？并解释下为什么？

作者：![AnsonZnl](https://avatars.githubusercontent.com/u/29278068?s=80&u=d0989f3ba8a133fbfef695a84b63c07a08d0d841&v=4)[AnsonZnl](https://github/AnsonZnl)

用一句话概括就是：
``` 
    EcmaScrpt规范定义Number的类型遵循了IEEE754-2008中的64位浮点数规则定义的小数后的有效位数至多为52位导致计算出现精度丢失问题！
    
```

这个问题也算是经常遇到的面试题之一了，楼上说的对，简单来说就是js中采用IEEE754的双精度标准，因为精度不足导致的问题，比如二进制表示0.1时这这样表示`1001100110011...`(0011无线循环)，那么这些循环的数字被js裁剪后，就会出现精度丢失的问题，也就造成了`0.1`不再是` 0.1 了`，而是变成了 `0.100000000000000002`  
我们可以来测试一下：
``` 
    0.100000000000000002 === 0.1//true
    
```

那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了 `0.200000000000000002`:
``` 
    0.200000000000000002 === 0.2 // true
    
```

由此我们可以得出:
``` 
    0.1 + 0.2 === 0.30000000000000004//true
    
```

所以自然`0.1+0.2!=0.3`。  
那么如何解决这个问题；使用原生最简单的方法:
``` 
    parseFloat((0.1+0.2).toFixed(10)) === 0.3//true
    
```

参考：  
深度剖析0.1 +0.2===0.30000000000000004的原因：<https://www.jianshu.com/p/d6b81e4e25e3>
